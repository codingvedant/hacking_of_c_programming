# Homework 07: Return Oriented Programming (ROP) Exploitation - Bypassing Non-Executable Stack Protection

**Author:** Vedant Bhalerao (vedantb@umd.edu)  
**Course:** ENPM691

## Overview

This assignment details the exploitation of a buffer overflow vulnerability using Return Oriented Programming (ROP) techniques to bypass Non-Executable (NX) stack protection. The exploit demonstrates how to chain together existing code segments (gadgets) within a vulnerable binary to achieve arbitrary code execution and spawn a shell, despite the presence of modern security mitigations. The methodology includes gadget discovery, payload construction, and practical exploitation using tools such as GDB, pwntools, and ropper.

> ⚠️ **Warning:** This assignment demonstrates advanced exploitation techniques for educational purposes only. These programs are designed to run in a controlled, isolated lab environment (VM) with security mitigations disabled. **NEVER** run these programs on production systems. See `SAFE_USAGE.md` in the repository root.

## Building

**Note:** This assignment requires:
- 32-bit compilation support
- Python 3 with pwntools library
- ropper tool for gadget discovery

Install dependencies:
```bash
# On Debian/Ubuntu:
sudo apt-get install gcc-multilib python3-pip
pip3 install pwntools ropper

# On Fedora:
sudo dnf install glibc-devel.i686 gcc-c++-i686 python3-pip
pip3 install pwntools ropper
```

```bash
make              # Build rop binary
make disable-aslr # Disable ASLR (required for exploit, needs sudo)
make exploit      # Run the ROP exploit
make enable-aslr  # Re-enable ASLR when done
make debug        # Run with GDB debugger
make find-string  # Find /bin/sh string address
make disasm       # Disassemble ROP gadgets
make clean        # Remove compiled binaries
```

## Programs

- **rop** - Vulnerable program with buffer overflow and ROP gadgets
- **exploit.py** - Python exploit script using pwntools to construct ROP chain

## Setup Instructions

1. **Build the binary:**
   ```bash
   make
   ```

2. **Disable ASLR (required for exploit to work with fixed addresses):**
   ```bash
   make disable-aslr
   # or manually:
   echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
   ```

3. **Verify binary security settings:**
   ```bash
   checksec rop
   # Should show NX enabled (stack non-executable)
   ```

## Running the Exploit

After disabling ASLR, run the exploit:

```bash
make exploit
# or manually:
python3 src/exploit.py
```

If successful, you should get a shell:
```bash
$ python3 src/exploit.py
[*] Payload length: 56
[+] Starting local process './rop': pid 46745
[*] Switching to interactive mode
/bin/sh is a great command, isn't it?
AAAAAAAAAAAAAAAA\xfa\x91\x04\x08\x0b
$ ls
exploit.py rop rop.c
$ whoami
vedant
$ exit
```

## ROP Chain Explanation

The exploit constructs a ROP chain that:

1. **Overwrites return address** with first gadget address
2. **Sets up execve syscall parameters:**
   - EAX = 0x0b (execve syscall number)
   - EBX = address of "/bin/sh" string
   - ECX = 0x0 (NULL for argv)
   - EDX = 0x0 (NULL for envp)
3. **Executes syscall** via `int 0x80`

The ROP gadgets are located in the `gogodaaget()` function:
- `pop eax; ret` at 0x080491fa
- `pop ebx; mov esi, 0x64; pop edi; ret` at 0x080491fc
- `pop ecx; mov ebx, 0xffffffff; ret` at 0x08049204
- `mov edx, 0; inc edx; ret` at 0x0804920b
- `dec edx; ret` at 0x08049212
- `int 0x80; nop; nop; ret` at 0x08049214

## Debugging with GDB

To examine the ROP chain execution:

```bash
gdb -q ./rop
(gdb) break Test
(gdb) run
(gdb) disassemble gogodaaget
(gdb) print &gogodaaget
(gdb) x/20x $esp
(gdb) continue
```

Use `ropper` to find gadgets:
```bash
ropper -f rop --string "/bin/sh"
ropper -f rop --search "pop eax"
```

## Compilation Flags

The Makefile uses specific flags:
- `-m32` - 32-bit (IA-32) executable
- `-g` - Debug symbols for source-level debugging
- `-no-pie` - Disable position-independent executable (for fixed addresses)
- `-mpreferred-stack-boundary=2` - Control stack alignment
- `-fno-pic` - Disable position-independent code
- `-fno-stack-protector` - Disable stack canaries

**Note:** NX protection is **enabled** by default (stack is non-executable), which is why we use ROP instead of shellcode injection.

## Security Notes

This assignment demonstrates ROP exploitation in a controlled environment. Key points:

- **NX Protection Bypass**: ROP bypasses NX by reusing existing executable code
- **ASLR Disabled**: Required for exploit to work with fixed gadget addresses
- **No Stack Canaries**: Disabled to allow buffer overflow
- **No PIE**: Disabled for predictable addresses

In production systems with full protections:
- **ASLR** would randomize addresses, requiring information leakage
- **Stack Canaries** would detect buffer overflows
- **CFI (Control Flow Integrity)** would prevent unexpected jumps
- **Compiler Hardening** would add additional protections

**Always re-enable ASLR when done:**
```bash
make enable-aslr
```

See `docs/` folder for detailed write-up and analysis.

