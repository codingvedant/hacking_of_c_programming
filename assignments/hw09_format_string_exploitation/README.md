# Homework 09: Format String Vulnerability Exploitation - Privilege Escalation via Return Address Overwrite

**Author:** Vedant Bhalerao (vedantb@umd.edu)  
**Course:** ENPM691

## Overview

This assignment demonstrates the exploitation of a format string vulnerability to achieve arbitrary code execution and privilege escalation in a SUID binary. The exploit leverages uncontrolled format string specifiers in the printf() function to overwrite the return address on the stack, redirecting program flow to a malicious target function that spawns a root shell. The methodology includes stack layout analysis using GDB, precise calculation of memory addresses, format string payload construction, and successful demonstration of control flow hijacking.

> ⚠️ **CRITICAL WARNING:** This assignment demonstrates privilege escalation exploitation techniques for educational purposes only. These programs are designed to run in a controlled, isolated lab environment (VM) with security mitigations disabled. **MUST** be run in an isolated VM environment. **NEVER** run these programs on production systems. See `SAFE_USAGE.md` in the repository root.

## Building

**Note:** This assignment requires 32-bit compilation. You may need to install 32-bit libraries:
- On Debian/Ubuntu: `sudo apt-get install gcc-multilib`
- On Fedora: `sudo dnf install glibc-devel.i686 gcc-c++-i686`

```bash
make              # Build vuln binary
make setup-suid   # Set SUID root privileges (requires sudo)
make disable-aslr # Disable ASLR (required for exploit, needs sudo)
make exploit      # Run the format string exploit
make enable-aslr  # Re-enable ASLR when done
make remove-suid  # Remove SUID privileges when done
make debug        # Run with GDB debugger
make find-addresses # Find function addresses
make test-offset  # Test format string offset
make clean        # Remove compiled binaries
```

## Programs

- **vuln** - Vulnerable SUID program with format string vulnerability
- **exploit.py** - Python exploit script that constructs format string payload

## Setup Instructions

1. **Build the binary:**
   ```bash
   make
   ```

2. **Set SUID privileges (requires root):**
   ```bash
   make setup-suid
   # or manually:
   sudo chown root:root vuln
   sudo chmod u+s vuln
   ```

3. **Disable ASLR (required for exploit to work with fixed addresses):**
   ```bash
   make disable-aslr
   # or manually:
   echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
   ```

4. **Verify binary security settings:**
   ```bash
   checksec vuln
   # Should show: No canary, NX disabled, No PIE
   ```

## Running the Exploit

After setting up SUID and disabling ASLR, run the exploit:

```bash
make exploit
# or manually:
python3 src/exploit.py
```

If successful, you should get a root shell:
```bash
$ python3 src/exploit.py
Return address location: 0xffffd37c
Target function: 0x80491f6
Bytes needed: 134517234
Executing exploit...
*** SHELL SPAWNED! SUCCESS! ***
*** You now have a root shell! ***
# whoami
root
# exit
```

## Format String Exploitation Details

The exploit works by:

1. **Finding the return address location** on the stack (e.g., 0xffffd37c)
2. **Calculating the target function address** (target_function at 0x80491f6)
3. **Constructing a format string payload:**
   - Place return address location at buffer start (offset 7)
   - Use `%[padding]c` to print exactly the target address value
   - Use `%7$n` to write that value to the address at offset 7
4. **Overwriting the return address** to point to target_function
5. **Executing target_function** which calls `setreuid()` and `system("/bin/sh")`

### Format String Payload Structure

```
[return_addr_location (4 bytes)] + %[padding]c%7$n
```

Where:
- `return_addr_location` is the address of the saved return address on the stack
- `padding` = target_address - 4 (to account for the 4 bytes already printed)
- `%7$n` writes the number of bytes printed to the address at offset 7

## Debugging with GDB

To analyze the format string vulnerability:

```bash
gdb -q ./vuln
(gdb) break vulnerable_function
(gdb) run "TEST"
(gdb) info frame
(gdb) x/wx $ebp+4  # View return address location
(gdb) run "AAAA%7\$x"  # Test format string offset
(gdb) continue
```

To find function addresses:
```bash
objdump -t vuln | grep target_function
```

## Compilation Flags

The Makefile uses specific flags to create a controlled lab environment:
- `-m32` - 32-bit (IA-32) executable
- `-fno-stack-protector` - Disable stack canaries
- `-z execstack` - Mark stack as executable
- `-no-pie` - Disable position-independent executable

**Note:** The format string vulnerability exists because `printf(buffer)` is used instead of `printf("%s", buffer)`.

## Security Notes

This assignment demonstrates format string exploitation in a controlled environment. Key points:

- **Format String Vulnerability**: Uncontrolled format string in `printf(buffer)`
- **Arbitrary Memory Write**: Using `%n` format specifier to write to memory
- **Return Address Overwrite**: Redirecting execution to target_function
- **SUID Privilege Escalation**: target_function maintains root privileges
- **ASLR Disabled**: Required for exploit to work with fixed addresses
- **No Stack Canaries**: Disabled to allow exploitation

In production systems with full protections:
- **Format String Warnings**: `-Wformat-security` would detect the vulnerability
- **ASLR** would randomize addresses, requiring information leakage
- **Stack Canaries** would detect stack corruption
- **PIE** would make addresses unpredictable
- **Secure Coding**: Always use `printf("%s", buffer)` instead of `printf(buffer)`

**Always re-enable ASLR and remove SUID privileges when done:**
```bash
make enable-aslr
make remove-suid
```

See `docs/` folder for detailed write-up and analysis.

