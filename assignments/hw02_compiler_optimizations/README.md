# Homework 02: Compiler Optimizations and Debugging through Multiplication Functions

**Author:** Vedant Bhalerao (vedantb@umd.edu)  
**Course:** ENPM691

## Overview

This assignment investigates how modern C compilers optimize multiplication by constant operands through strength reduction technique. Instead of doing general-purpose multiply instructions, compilers generate equivalent sequences of adds, subtracts, and shifts that are computationally preferable. Three programs were implemented to multiply an integer by 3, 7, and 12, respectively, and their compiled binaries were examined using gdb with pwndbg.

## Building

**Note:** This assignment requires 32-bit compilation. You may need to install 32-bit libraries:
- On Debian/Ubuntu: `sudo apt-get install gcc-multilib`
- On Fedora: `sudo dnf install glibc-devel.i686 gcc-c++-i686`

```bash
make              # Build all three programs (mulby3, mulby7, mulby12)
make run          # Build and run all programs
make debug        # Build and run mulby3 with GDB debugger
make clean        # Remove compiled binaries
```

## Programs

- `mulby3` - Multiplies input by 3
- `mulby7` - Multiplies input by 7
- `mulby12` - Multiplies input by 12

## Running

After building, run each program individually:

```bash
./mulby3
./mulby7
./mulby12
```

## Debugging with GDB

To examine the assembly code generated by the compiler:

```bash
gdb ./mulby3
(gdb) break mulBy3
(gdb) run
(gdb) disassemble mulBy3
(gdb) continue
```

Repeat for `mulby7` and `mulby12` to observe different optimization strategies.

## Compilation Flags

The Makefile uses specific flags to produce readable assembly:
- `-m32` - 32-bit object code
- `-g` - Debug symbols
- `-fno-stack-protector` - Disable stack canaries
- `-no-pie -fno-pic` - Disable position-independent code
- `-z execstack` - Mark stack as executable

## Expected Results

The programs demonstrate different compiler optimization strategies:
- **mulby3**: Uses `add eax,eax` followed by `add eax,edx` (2x + x = 3x)
- **mulby7**: Uses `shl eax,0x3` followed by `sub eax,edx` (8x - x = 7x)
- **mulby12**: Uses adds and shift: `add eax,eax; add eax,edx; shl eax,0x2` (3x * 4 = 12x)

See `docs/` folder for detailed write-up and analysis.

